{
    "contents" : "dissect <- function(a){\n  n <- nrow(a)\n  temp <- a\n  a.sym <- (a+t(a)) > 0\n  temp.sym <- a.sym\n  r <- list(a)\n  r.sym <- list(a.sym)\n  for (i in 1:(n-2)){\n    temp <- temp %*% a\n    temp.sym <- temp.sym %*% a.sym\n    r <- append(r, list(temp))\n    r.sym <- append(r.sym, list(temp.sym))\n  }\n  #return(r[[1]])\n  s.cy <- matrix(0, n, n) # same.cycle\n  s.co <- s.cy # same.component\n  for (i in 1:(n-1)){\n    for (j in 1:(n-1)){\n      s.cy <- s.cy + (r[[i]] * t(r[[j]]))\n    }\n    s.co <- s.co + r.sym[[i]]\n  }\n  s.cy <- 0 + (s.cy > 0)\n  if (any(s.cy == 1)) stop(\"loop\")\n  s.co <- 0 + (s.co > 0)\n  #s.cy <- s.cy + diag(n)\n  #s.cy <- unique.matrix(s.cy)\n  s.co <- unique.matrix(s.co)\n  \n  root <- which(colSums(a) == 0)\n  leaf <- which(rowSums(a) == 0)\n  comp <- list()\n  \n  order <- function(raw, part){\n    raw <- raw[!sapply(raw, function(x){x %in% part})]\n    raw <- append(raw, part)\n  }\n  \n  for (i in 1:nrow(s.co)){\n    nodes.i <- which(s.co[i,] == 1)\n    root.i <- intersect(root, nodes.i)\n    leaf.i <- intersect(leaf, nodes.i)\n    root.tell <- rep(-1,n)\n    leaf.tell <- rep(-1,n)\n    root.tell[root.i] <- 0\n    leaf.tell[leaf.i] <- 0\n    for (j in 1:(n-1)){\n      fil <- r[[j]][root.i,]\n      if (is.null(nrow(fil))) fil <- t(as.matrix(fil))\n      reach <- which(colSums(fil) > 0)\n      if (length(reach) == 0) break \n      root.tell[reach] <- j\n    }\n    depth.i <- max(root.tell)\n    for (j in 1:(n-1)){\n      reach <- which(rowSums(as.matrix(r[[j]][,leaf.i])) > 0)\n      if (length(reach) == 0) break \n      leaf.tell[reach] <- j\n    }\n    leaf.tell <- depth.i - leaf.tell\n  \n    lvl.i <- rep(-1,n)\n    skeleton <- which(leaf.tell == root.tell)\n    lvl.i[skeleton] <- leaf.tell[skeleton]\n    while (sum(lvl.i[nodes.i] == -1) != 0) {\n      for (j in 1:n)\n        if (!(j %in% skeleton) & (j %in% nodes.i)){\n          ske.par <- intersect(skeleton, which(a[,j] == 1))\n          ske.chi <- intersect(skeleton, which(a[j,] == 1))\n          par.tell <- integer()\n          chi.tell <- integer()\n          if (length(ske.par) > 0) par.tell <- lvl.i[ske.par] + 1\n          if (length(ske.chi) > 0) chi.tell <- lvl.i[ske.chi] - 1\n          lvl.i[j] <- round(mean(append(par.tell, chi.tell)))\n          if (!is.na(lvl.i[j])) skeleton <- append(skeleton,j)\n            else lvl.i[j] <- -1\n        }\n    }\n    new.order <- integer()\n    lvlSizes <- integer()\n    for (j in 0:depth.i){\n      new.order <- append(new.order, which(lvl.i == j))\n      lvlSizes <- append(lvlSizes, sum(lvl.i == j))\n    }\n    comp <- append(comp, list(list(matrix = a[new.order,new.order], level.sizes = lvlSizes)))\n  }\n  \n  list(ks = a, comp = comp)\n}\n\ntrim.2_loop <- function(a){\n  mul <- (a == 1) * (t(a) == 1) + 1\n  b <- a * mul\n  upper <- row(a) < col(a)\n  mul <- 1/(((b* upper) == 2) + 1)\n  b <- b * mul\n  b <- b * (1 - (b==2))\n}\n\n# it <- 50\n# poks <- gen(\"poks\", pars(items = it, students = 100))$poks\n# lea <- learn(\"poks\", poks)$po$ks\n# lea <- trim.2_loop(lea)\n# #viz(po)\n# b <- 0 + on.same.cycle(lea)\n# colnames(b) <- 1:it\n# rownames(b) <- 1:it\n# if (any(b==1)) print(\"tada\")",
    "created" : 1441430371503.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "642057972",
    "id" : "81DDA93D",
    "lastKnownWriteTime" : 7011605692497750387,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}