{
    "contents" : "---\ntitle: \"edmsyn package demo\"\nauthor: \"Hoang-Trieu Trinh\"\ndate: \"30 August 2015\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(cache=FALSE)\n```\n\n**0. Load the package**\n===============\n```{r load}\nlibrary(edmsyn)\nALL.MODELS\n```\n\n**1. Class `context` and function `pars()`**\n===============\n- An object of class `context` is a consistent list of all parameters from `ALL.MODELS`\n\n- Get a `context` from function `pars()`\n\n```{r examine_pars}\np <- pars(students = 20, items = 20)\nclass(p)\nnames(p)\np$avg.success\np\n```\n- Update `p` also by `pars()`\n```{r update_pars}\np <- pars(p, concepts = 5)\np\n```\n- `p$init.vals` contains all the default values, so that if a `NULL` parameter is in need, it will load its value from `p$init.vals` \n\n```{r init_vals}\nnames(p$init.vals)\np$init.vals$avg.success\n```\n\n`pars()` always make sure that there is no conflicts in the context\n```{r conflicts, error = TRUE}\np <- pars(p, Q = matrix(1,30,5))\n```\n\nThis is useful because some kinds of conflict are not always clear\n```{r conflict_avg, error = TRUE}\n#We know that avg.success == mean(st.exp) == mean(it.exp)\npars(st.exp = rep(0.3,100), it.exp = rep(0.2,20))\n```\nAt this point, it is good to notice that there are two reasons why `avg.success` must stay `NULL` until needed instead of taking the default value 0.5 right when `pars()` is called: \n\n- 0.5 may conflicts with some information the user input into `pars()`\n- There is no reason why `avg.success` should be activated if the user is looking at a model that does not use `avg.success`\n\nThe benefit of introducing this class is mostly convenience.\n\n- Useful when a user is working across many different models while considering some shared parameters.\n\n- Useful when a user wants different type of generating data without having to use many separate functions.\n\n\n**2. Get a parameter from a `context` by `get.par()`**\n===============================================\n```{r conventional_get}\np$students\nget.par(\"students\", p)\n```\nThe advantage of `get.par()` is :\n```{r get_par}\np$M\nget.par(\"M\",p)\n```\nSee the progress by option `progress = TRUE`\n```{r gen_M}\nget.par(\"M\",p,progress = TRUE)\n```\nNotice the result is different, this is because the generating process is probabilistic.\nTwo points worth noting:\n\n- Why `S` and some other parameters are activated while the generation method did not use these parameters?\n\n**answer**: Because `M` can also be generated by `S`, and there is enough information to generate `M` by this way.\n\n- So, why did `M` decides to be generated from `students`, `concept.exp` but not `S`?\n\n**answer**: This is due to a criterion that will be described in section 5. This complication arises from the fact that we are putting all kinds of parameter into one `context`, although originally `context` is meant for convenience.\n\nAnother advantage of `get.par()` :\n```{r conflict_p_}\np_ <- pars(students = 20, items = 15)\np_$Q\nget.par(\"Q\", p_)\np_ <- pars(p_, concepts = 4)\nget.par(\"Q\", p_)\n```\n\n**3. Generate data with `gen()`**\n=============================\n```{r gen_poks}\npoks.data <- gen(\"poks\",p, n=2)\npoks.data\n```\n\n`edmsyn` package views data as **a part of the context**, getting the data from a context is the same as getting a parameter from that context\nz\n```{r get_poks}\npoks.data[[1]]$po\npoks.data[[1]]$poks\n```\n\nSince data is a part of the context, we can generate it using `get.pars()`\n\n```{r get_par_data}\nget.par(\"poks\", p_)\n```\n\nIn fact, `gen()` is simply a wrapper of `get.par()` with some additional features : `progress`, `n`\n \n**Example:** More control over the `po` structure\n```{r control_poks}\np <- pars(p, density = 1, min.depth = 3, max.depth = 3, max.ntree = 1)\npoks.data <- gen(\"poks\",p)\npoks.data$po\n```\nOf course, we can always hand-design `po` and update it into `p` by `p <- pars(p, po = ...)`\n\nAnother example with DINA model:\n```{r dina}\ndina.data <- gen(\"dina\",p, progress = TRUE)\ndina.data\n```\n\nIn this case, `M` chooses to be generated by `students`, `skill.space`, `skill.dist` but not from `concept.exp`, `students` as in the previous example, or from `S`. Why? In this particular setting, this has to do with the fact that we are generating data from DINA model, and since `skill.space`, `skill.dist` are two parameters that can be learned directly from data by DINA model, hence it is reasonable to choose these two parameters over `S` in the process of generating DINA data.\n\n`gen()` only allows one model and one context at a time, we can save time generating data across many models and contexts using `gen.apply()`\n```{r gen_apply}\ndat.1 <- gen.apply(ALL.MODELS, list(p1 = p,p2 = p_), multiply = FALSE, n = 5)\ndat.1\ndat.2 <- gen.apply(ALL.MODELS, list(p1 = p,p2 = p_), multiply = TRUE, n = 5)\ndat.2\n```\n\n\n**4. Learning the most probable `context` from data using `learn()`**\n===============================================================\n```{r learn_poks}\n# get the 3rd iteration obtained from generating data from p1 by poks model\npoks.data <- dat.2[\"poks\",\"p1\"][[1]][[3]]\npoks.data\n# learn from poks.data\nlearnt.poks <- learn(\"poks\",data = poks.data$poks)\nlearnt.poks\n# percentage of similarity between the original po and learned po\nmean((poks.data$po + learnt.poks$po) != 1)\n```\nAnother example, here we learn from poks.data using DINA model.\n```{r dina_learn}\nQ <- get.par(\"Q\", p)$value\nR <- poks.data$poks$R\ndina.data <- list(R=R,Q=Q)\ndina.context <- learn(\"dina\", data = dina.data)\ndina.context\n```\nWe know that `skill.space` and `skill.dist`, but not `S`, is among the learnable parameters from DINA model, hence generating DINA data should use these parameters.\n\n```{r skill}\nget.par(\"skill.space\", dina.context)$value\nget.par(\"skill.dist\", dina.context)$value\n```\n\n**5. The overlap criterion **\n=============================\n\nThe set of directly learnable parameters from DINA model is:\n```{r dina_learnable}\nSTRUCTURE$dina$tell\n```\n\nDifferent ways to generate `M` are:\n```{r M_genfrom}\nSTRUCTURE$M$gen\n```\n\nThe criterion used to choose the generating method for `M` is the overlap size between each method listed above and the set of directly learnable parameters from DINA model.\n\nThis criterion can be interpreted as: *pick the method whose parameters are most likely to be learned from the target.*\n\nLooking back at `get.par(\"M\", p)`, the set of parameters that is directly learnable from `M` is \n```{r M_learnable}\nSTRUCTURE$M$tell\n```\n\nIt is now clear why `M` chooses `concept.exp` and `students` over `S` when the target is `M` itself.\n\nCurrently, the package provides no option other than this criterion for the users to manually handle similar situations.\n\nAnother example when the package automatically choose the method by *overlap* criterion:\n```{r criterion_eg}\ndummy <- get.par(\"S\", pars(concepts = 5, students = 20), progress = TRUE)\n# Learnable parameters from S\nSTRUCTURE$S$tell\n# Generating methods available for S \nSTRUCTURE$S$gen\n```\n\n\n**6. Generating synthetic data using `syn()`**\n================================\n\nGenerating synthetic data can be thought of as:\n\n- Learn the most probable `context` from a given data under a model's assumptions.\n- Change the learned `context` by keeping some of the parameters, changing some and discarding the rest.\n- Generate data from the new `context`.\n\n`edmsyn` provides `syn()` which automates the above process:\n\n- Learn the `context` by `learn()`\n- Keep the some parameters, by default these parameters are specified in `KEEP`, and discard the rest, allow the user to change parameter `students`. \n\n```{r keep}\nKEEP\n```\n\n*`KEEP` is designed in a way that, with any new value the user updates for `students`, the `context` is still consistent and sufficient, in this sense `syn()` generates synthetic data by creating simulated students.*\n\n- Generate synthetic data from new `context` by `gen()`\n\n```{r syn}\ndina.syn <- syn(\"dina\", data = dina.data, students = 12, n = 10)\ndina.syn$synthetic[[5]]$dina\n```\n\n`syn()` also have the argument `keep.pars`, where users can decide which parameters to keep, but take their own risk if the new value for `students` is not consistent with the retained information, or if the new `context` is not sufficient to generate synthetic data.\n\n```{r keep_change, error = TRUE}\ndina.syn <- syn(\"dina\", data = dina.data, keep.pars = c(\"Q\", \"concept.exp\"), students = 12)\ndina.syn <- syn(\"dina\", data = dina.data, keep.pars = c(\"Q\", \"M\"), students = 12)\n```\n\n**7. Additional features **\n==================================\n**7.1 More control on generating POK structure**\n-------------------------------------------------\n\n```{r po_control}\np <- pars(items = 20, min.ntree = 2, max.ntree = 2, \n          min.depth = 3, max.depth = 3,\n          min.it.per.tree = 5)\n```\n\n**7.2 Vizualizing POK structure**\n----------------------------------\n\n```{r po_viz}\npo <- get.par(\"po\", p)$value\n# Only applicable to po generated by get.par()\nviz(po)\n```\n\n**8. What remains**\n===================\n- The learning process for poks structure does not avoid loops. This makes the generating process after obtaining `po` cannot work properly.\n\n.................\n\n.....................\n\n.....................\n\n.................\n\n.................\n\n.....................\n\n.....................\n\n.................\n\n",
    "created" : 1441947644196.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4292070499",
    "id" : "965BD032",
    "lastKnownWriteTime" : 1444813693,
    "path" : "D:/github/edmsyn/edmsyndemo.Rmd",
    "project_path" : "edmsyndemo.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_markdown"
}