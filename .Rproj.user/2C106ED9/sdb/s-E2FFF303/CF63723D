{
    "contents" : "genPoks <- function(items, minTrees, maxTrees, minDepth, maxDepth,\n                    density, minItemPerTree, maxItemPerTree) {\n  print(\"here\")\n  print(c(minDepth, maxDepth, maxItemPerTree))\n  treeSizes <- NULL\n  treeDepths <- NULL\n  #-------------CISAC------------------------------------------------------\n  if (!is.null(treeSizes) &\n      !is.null(treeDepths) &\n      length(treeSizes) != length(treeDepths))\n    stop(\"Input Conflict\")\n  if (minDepth + 1 > maxItemPerTree)\n    stop(\"Requirements cannot be satisfied\")\n  if (items < minTrees * minItemPerTree |\n      items > maxTrees * maxItemPerTree)\n    stop(\"Requirements cannot be satisfied\")\n  \n  #-------------GENERATING-------------------------------------------------\n  \n  trees <- length(treeSizes)\n  if (is.null(treeSizes)) {\n    # pick a number of trees\n    lowerTrees <- max(minTrees,ceiling(items / maxItemPerTree))\n    upperTrees <- min(maxTrees,floor(items / max(minDepth + 1,minItemPerTree)))\n    if (lowerTrees > upperTrees)\n      stop(\"Requirements cannot be satisfied\")\n    if (!is.null(treeDepths)) {\n      if (length(treeDepths) < lowerTrees |\n          length(treeDepths) > upperTrees)\n        stop(\"Requirements cannot be satisfied\")\n      else\n        trees <- length(treeDepths)\n    }\n    else{\n      if (lowerTrees == upperTrees)\n        trees <- lowerTrees\n      else\n        trees <- sample(lowerTrees:upperTrees,1)\n    }\n    \n    # get the numbers of item on each tree\n    sampleTree <- function(itemsLeft, x) {\n      if (x == 1)\n        return(itemsLeft)\n      \n      lower <- itemsLeft - maxItemPerTree * (x - 1)\n      upper <-\n        itemsLeft - max(minDepth + 1,minItemPerTree) * (x - 1)\n      if (lower > maxItemPerTree)\n        stop(\"Requirements cannot be satisfied\")\n      if (upper < minItemPerTree)\n        stop(\"Requirements cannot be satisfied\")\n      \n      upper <- min(upper,maxItemPerTree)\n      if (upper < minDepth)\n        stop(\"Requirements cannot be satisfied\")\n      lower <- max(lower,minItemPerTree,minDepth + 1)\n      if (!is.null(treeDepths))\n        lower <- max(lower, treeDepths[trees - x + 1] + 1)\n      \n      \n      if (lower > upper)\n        stop(\"Requirements cannot be satisfied\")\n      if (lower == upper)\n        sampleResult <- lower\n      else\n        sampleResult <- sample(x = lower:upper,1)\n      \n      c(sampleResult,c(sampleTree(itemsLeft - sampleResult,x - 1)))\n    }\n    \n    #permute to remove bias from ordered sampling\n    perm <- sample(trees)\n    treeSizes <- sampleTree(items,trees)[perm]\n    if (!is.null(treeDepths))\n      treeDepths <- treeDepths[perm]\n  }\n  \n  if (!is.null(treeDepths)) {\n    if (sum((treeDepths + 1) > treeSizes) > 0)\n      stop(\"Requirements cannot be satisfied\")\n  }\n  else{\n    treeDepths <- numeric(trees)\n    for (i in 1:trees) {\n      upperDepth <- min(maxDepth, treeSizes[i] - 1)\n      if (minDepth == upperDepth)\n        treeDepths[i] <- minDepth\n      else\n        if (treeSizes[i] == 1)\n          treeDepths[i] <- 0\n        else\n          treeDepths[i] <- sample(1:upperDepth,1)\n    }\n  }\n  \n  #permute to remove bias from ordered samling\n  perm <- sample(items)\n  poks <- matrix(0,items,items)\n  subtrees <- list()\n  densFail <- FALSE\n  \n  sampleLevel <- function(itemsLeft,x) {\n    if (x == 1)\n      return(itemsLeft)\n    lower <- 1\n    upper <- itemsLeft - (x - 1)\n    if (lower == upper)\n      sampleResult <- lower\n    else\n      sampleResult <- sample(lower:upper,1)\n    c(sampleResult,c(sampleLevel(itemsLeft - sampleResult,x - 1)))\n  }\n  \n  for (i in 1:trees) {\n    size.i <- treeSizes[i]\n    levels <- treeDepths[i] + 1\n    levelSizes <-\n      sampleLevel(size.i,levels)[sample(levels)]\n    \n    # Skeleton\n    accumLvl <- cumsum(levelSizes)\n    \n    up_down <- function(node) {\n      atLevel <- sum(accumLvl < node) + 1\n      result <- sapply(1:size.i, function(x) {\n        xAtLvl <- sum(accumLvl < x) + 1\n        if (xAtLvl == atLevel + 1 | xAtLvl == atLevel - 1)\n          return(TRUE)\n        else\n          return(FALSE)\n      })\n    }\n    \n    mark <- rep(TRUE, size.i)\n    mark[sample(size.i,1)] <- FALSE\n    \n    while (sum(mark) != 0) {\n      pickFrom <- c(1:size.i)[!mark]\n      if (length(pickFrom) == 1)\n        begin <- pickFrom[1]\n      else\n        begin <- sample(pickFrom,1)\n      avail <- (up_down(begin) & mark)\n      if (sum(avail) == 0) next\n      pickFrom <- c(1:size.i)[avail]\n      if (length(pickFrom) == 1)\n        end <- pickFrom[1]\n      else\n        end <- sample(pickFrom,1)\n      mark[end] <- FALSE\n      poks[perm[min(begin,end)],perm[max(begin,end)]] <- 1\n    }\n    \n    if (size.i == 1) next\n    \n    groundLvl <- c(0,accumLvl)\n    pNow <- (size.i-1)/sum((c(1,levelSizes)*c(levelSizes,1))[2:levels])\n    if (pNow < 1){\n      p <- (density - pNow)/(1-pNow)\n      if (p < 0) densFail <- TRUE\n      else{\n        # Add random arc\n        for (j in 1:(levels-1))\n          for (k in 1:levelSizes[j])\n            for (m in 1:levelSizes[j+1]){\n              begin <- perm[groundLvl[j]+k]\n              end <- perm[groundLvl[j+1]+m]\n              if (poks[begin,end] == 0)\n                poks[begin,end] <- sample(0:1,1,prob = c(1-p,p))\n            }\n      }\n    }\n    # ###############\n    list.i <- perm[1:size.i]\n    tree.i <- as.matrix(poks[list.i,list.i])\n    colnames(tree.i) <- as.character(list.i)\n    rownames(tree.i) <- as.character(list.i)\n    tree.i <- list(tree.i, levelSizes)\n    names(tree.i) <- c(\"matrix\",\"level.sizes\")\n    subtrees <- append(subtrees,list(tree.i))\n    \n    perm <- perm[(size.i + 1):length(perm)]\n  }\n  \n  colnames(poks) <- as.character(1:items)\n  rownames(poks) <- colnames(poks)\n  \n  list(ks = poks, comp = subtrees)\n}\n",
    "created" : 1441183562535.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2772539426",
    "id" : "CF63723D",
    "lastKnownWriteTime" : 7011605692497750387,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}