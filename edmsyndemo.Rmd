---
title: "edmsyn package demo"
author: "Hoang-Trieu Trinh"
date: "30 August 2015"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE)
```

**0. Load the package**
===============
```{r load}
library(edmsyn)
ALL.MODELS
```

**1. Class `context` and function `pars()`**
===============
- An object of class `context` is a consistent list of all parameters from `ALL.MODELS`

- Get a `context` from function `pars()`

```{r examine_pars}
p <- pars(students = 20, items = 20)
class(p)
names(p)
p$avg.success
p
```
- Update `p` also by `pars()`
```{r update_pars}
p <- pars(p, concepts = 5)
p
```
- `p$init.vals` contains all the default values, so that if a `NULL` parameter is in need, it will load its value from `p$init.vals` 

```{r init_vals}
names(p$init.vals)
p$init.vals$avg.success
```

`pars()` always make sure that there is no conflicts in the context
```{r conflicts, error = TRUE}
p <- pars(p, Q = matrix(1,30,5))
```

This is useful because some kinds of conflict are not always clear
```{r conflict_avg, error = TRUE}
#We know that avg.success == mean(st.exp) == mean(it.exp)
pars(st.exp = rep(0.3,100), it.exp = rep(0.2,20))
```
At this point, it is good to notice that there are two reasons why `avg.success` must stay `NULL` until needed instead of taking the default value 0.5 right when `pars()` is called: 

- 0.5 may conflicts with some information the user input into `pars()`
- There is no reason why `avg.success` should be activated if the user is looking at a model that does not use `avg.success`

The benefit of introducing this class is mostly convenience.

- Useful when a user is working across many different models while considering some shared parameters.

- Useful when a user wants different type of generating data without having to use many separate functions.


**2. Get a parameter from a `context` by `get.par()`**
===============================================
```{r conventional_get}
p$students
get.par("students", p)
```
The advantage of `get.par()` is :
```{r get_par}
p$M
get.par("M",p)
```
See the progress by option `progress = TRUE`
```{r gen_M}
get.par("M",p,progress = TRUE)
```
Notice the result is different, this is because the generating process is probabilistic.
Two points worth noting:

- Why `S` and some other parameters are activated while the generation method did not use these parameters?

**answer**: Because `M` can also be generated by `S`, and there is enough information to generate `M` by this way.

- So, why did `M` decides to be generated from `students`, `concept.exp` but not `S`?

**answer**: This is due to a criterion that will be described in section 5. This complication arises from the fact that we are putting all kinds of parameter into one `context`, although originally `context` is meant for convenience.

Another advantage of `get.par()` :
```{r conflict_p_}
p_ <- pars(students = 20, items = 15)
p_$Q
get.par("Q", p_)
p_ <- pars(p_, concepts = 4)
get.par("Q", p_)
```

**3. Generate data with `gen()`**
=============================
```{r gen_poks}
poks.data <- gen("poks",p, n=2)
poks.data
```

`edmsyn` package views data as **a part of the context**, getting the data from a context is the same as getting a parameter from that context

```{r get_poks}
poks.data[[1]]$po
poks.data[[1]]$poks
```

Since data is a part of the context, we can generate it using `get.pars()`

```{r get_par_data}
get.par("poks", p_)
```

In fact, `gen()` is simply a wrapper of `get.par()` with some additional features : `progress`, `n`
 
**Example:** More control over the `po` structure
```{r control_poks}
p <- pars(p, density = 1, min.depth = 3, max.depth = 3, max.ntree = 1)
poks.data <- gen("poks",p)
poks.data$po
```
Of course, we can always hand-design `po` and update it into `p` by `p <- pars(p, po = ...)`

Another example with DINA model:
```{r dina}
dina.data <- gen("dina",p, progress = TRUE)
dina.data
```

In this case, `M` chooses to be generated by `students`, `skill.space`, `skill.dist` but not from `concept.exp`, `students` as in the previous example, or from `S`. Why? In this particular setting, this has to do with the fact that we are generating data from DINA model, and since `skill.space`, `skill.dist` are two parameters that can be learned directly from data by DINA model, hence it is reasonable to choose these two parameters over `S` in the process of generating DINA data.

`gen()` only allows one model and one context at a time, we can save time generating data across many models and contexts using `gen.apply()`
```{r gen_apply}
dat.1 <- gen.apply(ALL.MODELS, list(p1 = p,p2 = p_), multiply = FALSE, n = 5)
dat.1
dat.2 <- gen.apply(ALL.MODELS, list(p1 = p,p2 = p_), multiply = TRUE, n = 5)
dat.2
```


**4. Learning the most probable `context` from data using `learn()`**
===============================================================
```{r learn_poks}
# get the 3rd iteration obtained from generating data from p1 by poks model
poks.data <- dat.2["poks","p1"][[1]][[3]]
poks.data
# learn from poks.data
learnt.poks <- learn("poks",data = poks.data$poks)
learnt.poks
# percentage of similarity between the original po and learned po
mean((poks.data$po + learnt.poks$po) != 1)
```
Another example, here we learn from poks.data using DINA model.
```{r dina_learn}
Q <- get.par("Q", p)$value
R <- poks.data$poks$R
dina.data <- list(R=R,Q=Q)
dina.context <- learn("dina", data = dina.data)
dina.context
```
We know that `skill.space` and `skill.dist`, but not `S`, is among the learnable parameters from DINA model, hence generating DINA data should use these parameters.

```{r skill}
get.par("skill.space", dina.context)$value
get.par("skill.dist", dina.context)$value
```

**5. The overlap criterion **
=============================

The set of directly learnable parameters from DINA model is:
```{r dina_learnable}
STRUCTURE$dina$tell
```

Different ways to generate `M` are:
```{r M_genfrom}
STRUCTURE$M$gen
```

The criterion used to choose the generating method for `M` is the overlap size between each method listed above and the set of directly learnable parameters from DINA model.

This criterion can be interpreted as: *pick the method whose parameters are most likely to be learned from the target.*

Looking back at `get.par("M", p)`, the set of parameters that is directly learnable from `M` is 
```{r M_learnable}
STRUCTURE$M$tell
```

It is now clear why `M` chooses `concept.exp` and `students` over `S` when the target is `M` itself.

Currently, the package provides no option other than this criterion for the users to manually handle similar situations.

Another example when the package automatically choose the method by *overlap* criterion:
```{r criterion_eg}
dummy <- get.par("S", pars(concepts = 5, students = 20), progress = TRUE)
# Learnable parameters from S
STRUCTURE$S$tell
# Generating methods available for S 
STRUCTURE$S$gen
```


**6. Generating synthetic data using `syn()`**
================================

Generating synthetic data can be thought of as:

- Learn the most probable `context` from a given data under a model's assumptions.
- Change the learned `context` by keeping some of the parameters, changing some and discarding the rest.
- Generate data from the new `context`.

`edmsyn` provides `syn()` which automates the above process:

- Learn the `context` by `learn()`
- Keep the some parameters, by default these parameters are specified in `KEEP`, and discard the rest, allow the user to change parameter `students`. 

```{r keep}
KEEP
```

*`KEEP` is designed in a way that, with any new value the user updates for `students`, the `context` is still consistent and sufficient, in this sense `syn()` generates synthetic data by creating simulated students.*

- Generate synthetic data from new `context` by `gen()`

```{r syn}
dina.syn <- syn("dina", data = dina.data, students = 12, n = 10)
dina.syn$synthetic[[5]]$dina
```

`syn()` also have the argument `keep.pars`, where users can decide which parameters to keep, but take their own risk if the new value for `students` is not consistent with the retained information, or if the new `context` is not sufficient to generate synthetic data.

```{r keep_change, error = TRUE}
dina.syn <- syn("dina", data = dina.data, keep.pars = c("Q", "concept.exp"), students = 12)
dina.syn <- syn("dina", data = dina.data, keep.pars = c("Q", "M"), students = 12)
```

**7. Additional features **
==================================
**7.1 More control on generating POK structure**
-------------------------------------------------

```{r po_control}
p <- pars(items = 20, min.ntree = 2, max.ntree = 2, 
          min.depth = 3, max.depth = 3,
          min.it.per.tree = 5)
```

**7.2 Vizualizing POK structure**
----------------------------------

```{r po_viz}
po <- get.par("po", p)$value
# Only applicable to po generated by get.par()
viz(po)
```

**8. What remains**
===================
- The learning process for poks structure does not avoid loops. This makes the generating process after obtaining `po` cannot work properly.

.................

.....................

.....................

.................

.................

.....................

.....................

.................

